<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ROS中action通信</title>
      <link href="/2020/08/25/ROS%E4%B8%ADaction%E9%80%9A%E4%BF%A1/"/>
      <url>/2020/08/25/ROS%E4%B8%ADaction%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="action-的说明"><a href="#action-的说明" class="headerlink" title="action 的说明"></a><code>action</code> 的说明</h2><p>ROS中常用的通信方式是话题(Topic)和服务(Service)<br>action是一种类似于 Service 的问答通信机制，不同之处在于 action 带有连续反馈，可以不断反馈任务进度，也可以在任务过程中中止运行。</p><h2 id="action-的工作机制"><a href="#action-的工作机制" class="headerlink" title="action 的工作机制"></a><code>action</code> 的工作机制</h2><p>Client 和 Server 之间通过actionlib定义的“action protocol”进行通信。这种通信协议基于ROS的话题机制实现，为用户提供如下图所示Client和Server的接口。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/krilyang/imagecloud/raw/master/images/20200825200407.png"></p><p>Client 向 Server 端发布任务目标以及在必要的时候取消任务，Server 会向 Client 发布当前状态、实时反馈和任务执行的最终结果。</p><ul><li><p>goal：发布任务目标</p></li><li><p>cancel：请求取消任务</p></li><li><p>status：通知 Client 当前状态</p></li><li><p>feedback：周期反馈任务运行的监控数据</p></li><li><p>result：向 Client 发送任务的执行结果，只发布一次</p><h2 id="action-的定义"><a href="#action-的定义" class="headerlink" title="action 的定义"></a><code>action</code> 的定义</h2></li></ul><p>同 ROS 中的 message 通过<code>.msg</code>文件定义，service 通过 <code>.srv </code>文件定义一样，action 通过 <code>.action</code>来定义，放置在功能包的 action 文件夹下，<code>.action</code>文件有目标定义，然后是结果定义，然后是反馈定义，每个部分用3个连字符(<strong><code>---</code></strong>)分隔。参考官网的一个<a href="http://wiki.ros.org/cn/actionlib">例子</a>,定义 <code>DoDishes.action</code> 格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 定义目标信息 goal</span><br><span class="line">uint32 dishwasher_id  # Specify which dishwasher we want to use</span><br><span class="line">---</span><br><span class="line"># 定义结果信息 result</span><br><span class="line">uint32 total_dishes_cleaned</span><br><span class="line">---</span><br><span class="line"># 定义周期反馈的消息 feedback</span><br><span class="line">float32 percent_complete</span><br></pre></td></tr></table></figure><h2 id="创建-action-功能包"><a href="#创建-action-功能包" class="headerlink" title="创建 action 功能包"></a>创建 <code>action</code> 功能包</h2><p>使用 <code>catkin</code> 命令 <code>catkin_create_pkg</code> 创建 <code>action</code> 功能包</p><p>创建.action文件之后，还需要将这个文件编译，在CMakeLists.txt文件中添加如下编译规则：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED genmsg actionlib_msgs actionlib)</span><br><span class="line">add_action_files(DIRECTORY action FILES DoDishes.action)</span><br><span class="line">generate_messages(DEPENDENCIES actionlib_msgs)</span><br></pre></td></tr></table></figure><p>在功能包的package.xml中添加如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>actionlib<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>actionlib_msgs<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>actionlib<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>actionlib_msgs<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br></pre></td></tr></table></figure><p>进行编译，编译完成后会生成一系列 <code>.msg</code> 文件 和一系列 <code>.h</code> 头文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># path：catkin_ws/devel/share/action/msg</span><br><span class="line">DoDishesAction.msg</span><br><span class="line">DoDishesActionGoal.msg</span><br><span class="line">DoDishesActionResult.msg</span><br><span class="line">DoDishesActionFeedback.msg</span><br><span class="line">DoDishesGoal.msg</span><br><span class="line">DoDishesResult.msg</span><br><span class="line">DoDishesFeedback.msg</span><br><span class="line"># path: catkin_ws/devel/include/action</span><br><span class="line">DoDishesAction.h</span><br><span class="line">DoDishesActionGoal.h</span><br><span class="line">DoDishesActionResult.h</span><br><span class="line">DoDishesActionFeedback.h</span><br><span class="line">DoDishesGoal.h</span><br><span class="line">DoDishesResult.h</span><br><span class="line">DoDishesFeedback.h</span><br></pre></td></tr></table></figure><h2 id="action-通信"><a href="#action-通信" class="headerlink" title="action 通信"></a><code>action</code> 通信</h2><p>在 <code>.action</code> 的定义中，描述了一个洗盘子的任务，还需要创建一个功能包定义<code>客户端</code>和<code>服务端</code>,实现通信。</p><ul><li><font color=green>创建客户端</font></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;actionlib/client/simple_action_client.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;action_tutorials/DoDishesAction.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> actionlib::SimpleActionClient&lt;action_tutorials::DoDishesAction&gt; <span class="built_in">Client</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当action完成后会调用该回调函数一次</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doneCb</span><span class="params">(<span class="keyword">const</span> actionlib::SimpleClientGoalState&amp; state,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">const</span> action_tutorials::DoDishesResultConstPtr&amp; result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ROS_INFO(<span class="string">&quot;Yay! The dishes are now clean&quot;</span>);</span><br><span class="line">   ros::<span class="built_in">shutdown</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当action激活后会调用该回调函数一次</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activeCb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ROS_INFO(<span class="string">&quot;Goal just went active&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 收到feedback后调用该回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">feedbackCb</span><span class="params">(<span class="keyword">const</span> action_tutorials::DoDishesFeedbackConstPtr&amp; feedback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ROS_INFO(<span class="string">&quot; percent_complete : %f &quot;</span>, feedback-&gt;percent_complete);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ros::init(argc, argv, <span class="string">&quot;do_dishes_client&quot;</span>);</span><br><span class="line">   <span class="comment">// 定义一个客户端</span></span><br><span class="line">   <span class="function"><span class="built_in">Client</span> <span class="title">client</span><span class="params">(<span class="string">&quot;do_dishes&quot;</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">   <span class="comment">// 等待服务器端</span></span><br><span class="line">   ROS_INFO(<span class="string">&quot;Waiting for action server to start.&quot;</span>);</span><br><span class="line">   client.waitForServer();</span><br><span class="line">   ROS_INFO(<span class="string">&quot;Action server started, sending goal.&quot;</span>);</span><br><span class="line">   <span class="comment">// 创建一个action的goal</span></span><br><span class="line">   action_tutorials::DoDishesGoal goal;</span><br><span class="line">   goal.dishwasher_id = <span class="number">1</span>;</span><br><span class="line">   <span class="comment">// 发送action的goal给服务器端，并且设置回调函数</span></span><br><span class="line">   client.sendGoal(goal,  &amp;doneCb, &amp;activeCb, &amp;feedbackCb);</span><br><span class="line">   ros::spin();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 对于C++ <code>SimpleActionClient</code>, 如果一个单独的线程正在为客户机的回调队列服务,<code>waitForServer</code>方法将会工作。使用多线程的spinner运行，或者使用自己的线程来服务ROS回调队列，这需要在客户机的构造函数的<code>spin_thread</code>选项中传递<code>true</code>。</p><ul><li><font color=green>创建服务端</font></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;actionlib/server/simple_action_server.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;action_tutorials/DoDishesAction.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> actionlib::SimpleActionServer&lt;action_tutorials::DoDishesAction&gt; <span class="built_in">Server</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收到action的goal后调用该回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">const</span> action_tutorials::DoDishesGoalConstPtr&amp; goal, <span class="built_in">Server</span>* as)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">ros::Rate <span class="title">r</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">   action_tutorials::DoDishesFeedback feedback;</span><br><span class="line">   ROS_INFO(<span class="string">&quot;Dishwasher %d is working.&quot;</span>, goal-&gt;dishwasher_id);</span><br><span class="line">   <span class="comment">// 假设洗盘子的进度，并且按照1hz的频率发布进度feedback</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">10</span>; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       feedback.percent_complete = i * <span class="number">10</span>;</span><br><span class="line">       as-&gt;publishFeedback(feedback);</span><br><span class="line">       r.sleep();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 当action完成后，向客户端返回结果</span></span><br><span class="line">   ROS_INFO(<span class="string">&quot;Dishwasher %d finish working.&quot;</span>, goal-&gt;dishwasher_id);</span><br><span class="line">   as-&gt;setSucceeded();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ros::init(argc, argv, <span class="string">&quot;do_dishes_server&quot;</span>);</span><br><span class="line">   ros::NodeHandle n;</span><br><span class="line">   <span class="comment">// 定义一个服务器</span></span><br><span class="line">   <span class="function"><span class="built_in">Server</span> <span class="title">server</span><span class="params">(n, <span class="string">&quot;do_dishes&quot;</span>, boost::bind(&amp;execute, _1, &amp;server), <span class="literal">false</span>)</span></span>;</span><br><span class="line">   <span class="comment">// 服务器开始运行</span></span><br><span class="line">   server.start();</span><br><span class="line">   ros::spin();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gitee + Picgo 搭建图床</title>
      <link href="/2020/08/20/gitee-Picgo-%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/"/>
      <url>/2020/08/20/gitee-Picgo-%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="安装Picgo"><a href="#安装Picgo" class="headerlink" title="安装Picgo"></a>安装Picgo</h2><ul><li>从官网下载安装 <a href="https://github.com/Molunerfinn/PicGo">Picgo</a> </li></ul><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/krilyang/imagecloud/raw/master/images/20200820093208.png" style="zoom: 67%;" /><ul><li>需要在插件设置中搜索 <font color=orange>gitee</font> 安装 <font color=orange>gitee-uploader</font> 插件，因为 <font color=orange>giteee</font> 不是默认加载的图床。（ps:安装插件前需要提前安装 <a href="https://nodejs.org/en/">node.js</a>)</li></ul><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/krilyang/imagecloud/raw/master/images/20200820093811.png" style="zoom:67%;" /><h2 id="注册码云（Gitee）创建仓库"><a href="#注册码云（Gitee）创建仓库" class="headerlink" title="注册码云（Gitee）创建仓库"></a>注册码云（Gitee）创建仓库</h2><p>在码云网站点击右上角 + 新建仓库</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/krilyang/imagecloud/raw/master/images/20200820100143.png" style="zoom:67%;" /><h2 id="配置-Picgo"><a href="#配置-Picgo" class="headerlink" title="配置 Picgo"></a>配置 Picgo</h2><p>点击左侧图床设置，进入 <font color=orange>gitee</font> 设置</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/krilyang/imagecloud/raw/master/images/20200820101024.png" style="zoom:67%;" /><ul><li>repo : 用户名/创建的仓库名称</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/krilyang/imagecloud/raw/master/images/20200820100629.png"></p><ul><li><p>token : 码云的私人令牌</p><p>1.点击右上角头像，进入设置界面</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/krilyang/imagecloud/raw/master/images/20200820101356.png"></p><p>2.找到左侧安全设置中私人令牌，点击<code>生成新令牌</code>，把 <font color=green>projects</font> 这一项勾上，其他的不用勾选，然后点击提交。</p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/krilyang/imagecloud/raw/master/images/20200820101502.png"></p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/krilyang/imagecloud/raw/master/images/20200820101705.png"  /><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/krilyang/imagecloud/raw/master/images/20200820102208.png"></p><h2 id="上传图片，进行验证"><a href="#上传图片，进行验证" class="headerlink" title="上传图片，进行验证"></a>上传图片，进行验证</h2>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows下实用工具</title>
      <link href="/2020/08/20/Windows%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
      <url>/2020/08/20/Windows%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h4 id="cmder"><a href="#cmder" class="headerlink" title="cmder"></a>cmder</h4><h4 id="Picgo"><a href="#Picgo" class="headerlink" title="Picgo"></a>Picgo</h4><h4 id="Snipaste"><a href="#Snipaste" class="headerlink" title="Snipaste"></a>Snipaste</h4><h4 id="Quicklook"><a href="#Quicklook" class="headerlink" title="Quicklook"></a>Quicklook</h4><h4 id="Synergy"><a href="#Synergy" class="headerlink" title="Synergy"></a>Synergy</h4><h4 id="Everything"><a href="#Everything" class="headerlink" title="Everything"></a>Everything</h4><h4 id="rufus"><a href="#rufus" class="headerlink" title="rufus"></a>rufus</h4><h4 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h4><h4 id="Mobirise"><a href="#Mobirise" class="headerlink" title="Mobirise"></a>Mobirise</h4><h4 id="TranslucentTB"><a href="#TranslucentTB" class="headerlink" title="TranslucentTB"></a>TranslucentTB</h4><h4 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h4>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习笔记</title>
      <link href="/2020/05/18/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/05/18/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Git学习笔记"><a href="#Git学习笔记" class="headerlink" title="Git学习笔记"></a>Git学习笔记</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>首先推荐一款快速学习Git的工具——<a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git</a>通过游戏的方式，进行深入学习。</li><li>关于Git的详细介绍，参考<a href="https://www.yiibai.com/git">Git教程</a></li></ul><h3 id="Git常用基础命令"><a href="#Git常用基础命令" class="headerlink" title="Git常用基础命令"></a>Git常用基础命令</h3><h4 id="1-Git-Init"><a href="#1-Git-Init" class="headerlink" title="1.Git Init"></a>1.Git Init</h4><p>&emsp;&emsp;<font color=orange>git commit</font> 命令创建一个空的Git仓库或重新初始化一个现有仓库，即使在现有存储库中运行git init命令也是安全的，它不会覆盖已经存在的东西。</p><h4 id="2-Git-Add"><a href="#2-Git-Add" class="headerlink" title="2.Git Add"></a>2.Git Add</h4><p>&emsp;&emsp;<font color=orange>git add</font> 命令将文件内容添加到索引(将修改添加到暂存区)。也就是将要提交的文件的信息添加到索引库中。该命令可以在提交之前多次执行。它只在运行git add命令时添加指定文件的内容; 如果希望随后的更改包含在下一个提交中，那么必须再次运行git add将新的内容添加到索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;git add &lt;path&gt; 基本用法，&lt;path&gt;可以是文件也可以是目录。</span><br><span class="line">$ git add documentation&#x2F;*.txt &#x2F;&#x2F;添加documentation目录及其子目录下所有*.txt文件的内容。</span><br><span class="line">$ git add . &#x2F;&#x2F;将所有修改添加到暂存区。</span><br><span class="line">$ git add * &#x2F;&#x2F;Ant风格添加修改。</span><br><span class="line">$ git add *Controller &#x2F;&#x2F;将以Controller结尾的文件的所有修改添加到暂存区。</span><br><span class="line">$ git add Hello* &#x2F;&#x2F;将所有以Hello开头的文件的修改添加到暂存区.例如:HelloWorld.txt,Hello.java,HelloGit.txt ...</span><br><span class="line">$ git add Hello? &#x2F;&#x2F;将以Hello开头后面只有一位的文件的修改提交到暂存区.例如:Hello1.txt,HelloA.java 如果是HelloGit.txt或者Hello.java是不会被添加的。</span><br><span class="line">$ git add -i &#x2F;&#x2F;查看中被所有修改过或已删除文件但没有提交的文件。</span><br></pre></td></tr></table></figure><h4 id="3-Git-Clone"><a href="#3-Git-Clone" class="headerlink" title="3.Git Clone"></a>3.Git Clone</h4><p>&emsp;&emsp;<font color=blue>git clone</font> 命令将存储库克隆到新目录中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone &lt;版本库的网址&gt;</span><br></pre></td></tr></table></figure><h4 id="4-Git-Commit"><a href="#4-Git-Commit" class="headerlink" title="4.Git Commit"></a>4.Git Commit</h4><p>&emsp;&emsp;<font color=orange>git commit </font>命令用于将更改记录(提交)到存储库。将索引的当前内容与描述更改的用户和日志消息一起存储在新的提交中。</p><h4 id="5-Git-Status"><a href="#5-Git-Status" class="headerlink" title="5.Git Status"></a>5.Git Status</h4><p>&emsp;&emsp;<font color=orange>git status </font>命令用于显示工作目录和暂存区的状态。使用此命令能看到那些修改被暂存到了, 哪些没有, 哪些文件没有被Git tracked到。git status不显示已经commit到项目历史中去的信息。看项目历史的信息要使用git log。</p><h4 id="6-Git-Reset"><a href="#6-Git-Reset" class="headerlink" title="6.Git Reset"></a>6.Git Reset</h4><p>&emsp;&emsp;<font color=orange>git reset </font>命令用于将当前HEAD复位到指定状态。一般用于撤消之前的一些操作(如：git add,git commit等)</p><h4 id="7-Git-Branch"><a href="#7-Git-Branch" class="headerlink" title="7.Git Branch"></a>7.Git Branch</h4><p>&emsp;&emsp;<font color=orange>git branch </font>命令用于列出，创建或删除分支。</p><ul><li><strong>查看当前有哪些分支</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">  master</span><br><span class="line">  *branch</span><br><span class="line">  &#x2F;&#x2F;当前有两个分支：master和branch，当前在new_branch分支上，它前面有个星号(*)。</span><br></pre></td></tr></table></figure><ul><li><strong>新建一个分支</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch new_branch &#x2F;&#x2F;此命令将新建一个new_branch分支。</span><br></pre></td></tr></table></figure><ul><li><strong>切换到指定分支</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout new_branch</span><br><span class="line">$ git branch&#x2F;&#x2F;再次查看分支</span><br><span class="line">  *new_branch</span><br><span class="line">   master</span><br><span class="line">   branch</span><br><span class="line">$ git checkout -b mybranch &#x2F;&#x2F;创建并切换分支</span><br></pre></td></tr></table></figure><ul><li><strong>查看本地和远程分支</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -a &#x2F;&#x2F;列出本地和远程所有分支</span><br><span class="line">$ git branch -r &#x2F;&#x2F;列出所有远程分支</span><br></pre></td></tr></table></figure><ul><li><strong>修改分支名字</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -m old_branch new _branch</span><br></pre></td></tr></table></figure><ul><li><strong>删除分支</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d mybranch&#x2F;&#x2F;删除分支</span><br><span class="line">$ git branch -D mybranch&#x2F;&#x2F;强制删除分支</span><br><span class="line">$ git push origin --delete r_branch&#x2F;&#x2F;删除远程分支</span><br></pre></td></tr></table></figure><ul><li><strong>合并分支</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master&#x2F;&#x2F;切换到master分支</span><br><span class="line">$ git merge mybranch&#x2F;&#x2F;合并branch分支到当前分支master下</span><br></pre></td></tr></table></figure><ul><li><strong>更新远程仓库到本地&amp;&amp;推送分支</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin&#x2F;&#x2F;更新远程库到本地</span><br><span class="line">$ git pull  next &#x2F;&#x2F;git pull命令用于从另一个存储库或本地分支获取并集成(整合)。</span><br><span class="line">$ git push origin mybranch&#x2F;&#x2F;推送分支</span><br></pre></td></tr></table></figure><h4 id="8-Git-Rm-amp-amp-Git-Mv"><a href="#8-Git-Rm-amp-amp-Git-Mv" class="headerlink" title="8.Git Rm &amp;&amp; Git Mv"></a>8.Git Rm &amp;&amp; Git Mv</h4><p>&emsp;&emsp;<font color=orange>git rm</font> 命令用于从工作区和索引中删除文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git rm -r mydir &#x2F;&#x2F;删除文件夹 mydir，并把它从git的仓库管理系统中移除。</span><br><span class="line">$ git rm text1.txt &#x2F;&#x2F;删除 text1.txt文件，并把它从git的仓库管理系统中移除。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<font color=orange>git mv</font> 命令用于移动或重命名文件，目录或符号链接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git mv text.txt mydir &#x2F;&#x2F;把一个文件 text.txt 移动到 mydir .</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<font color=Green>目前常用到的命令暂时就这些，如用到其余命令以后再作补充。</font></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是卡尔曼滤波</title>
      <link href="/2020/02/24/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/"/>
      <url>/2020/02/24/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="卡尔曼滤波原理"><a href="#卡尔曼滤波原理" class="headerlink" title="卡尔曼滤波原理"></a>卡尔曼滤波原理</h1><p>&emsp;&emsp;本文主要根据国外一篇文章翻译而来,<a href="http://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/">How a Kalman filter works, in pictures</a></p><h2 id="什么是卡尔曼滤波？"><a href="#什么是卡尔曼滤波？" class="headerlink" title="什么是卡尔曼滤波？"></a>什么是卡尔曼滤波？</h2><p>&emsp;&emsp;你可以在任何含有<strong>不确定信息</strong>的某个动态系统中使用卡尔曼滤波，并且能够对系统下一步的走向做出<strong>有根据的预测</strong>，即使伴随着各种干扰，卡尔曼滤波总是能指出真实发生的情况。<br>&emsp;&emsp;卡尔曼滤波器非常适合<strong>连续变化的系统</strong>，它的优点是可以节约内存（除了前一个状态量外，不需要保留其它历史数据），而且速度很快，很适合应用于实时问题和嵌入式系统。<br>&emsp;&emsp;通常大多数关于实现卡尔曼滤波的数学公式看起来有点晦涩难懂，这个状况有点糟糕。不过如果以正确的方式看待它，卡尔曼滤波是非常简单和容易理解的，下面我将用漂亮的图片和色彩清晰的阐述它，你只需要懂一些基本的概率和矩阵的知识就可以了。</p><h2 id="卡尔曼滤波能做什么？"><a href="#卡尔曼滤波能做什么？" class="headerlink" title="卡尔曼滤波能做什么？"></a>卡尔曼滤波能做什么？</h2><p>&emsp;&emsp;让我们举一个玩具示例：您已经建立了一个可以在树林中四处走动的小型机器人，并且该机器人需要知道它的确切位置，以便可以导航。</p><div align="center"> <img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/GuMuFeng/picture/master/kalman/kalman_1.jpg"  width="300px"> </div><br><p>&emsp;&emsp;我们可以说机器人有一个状态向量 $\vec{x_k}$, 表示位置和速度：<br>$$ \vec{x_k} = (\vec{p}, \vec{v}) $$<br>&emsp;&emsp;注意这个状态向量只是关于这个系统基本属性的一堆数字，它可以是任何其它的东西。在这个例子中是位置和速度，它也可以是一个油箱中液体的总量，汽车发动机的温度，用户手指在触摸板上的位置坐标，或者任何你需要跟踪的信号。<br>&emsp;&emsp;我们的机器人还具有一个GPS传感器，该传感器的精确度约为10米，这很好，但是它需要知道的位置精度不止10米。这些树林里有很多沟壑和悬崖，如果机器走错了几英尺，它可能会从悬崖上掉下来。因此这个GPS本身还不够好。</p><div align="center"> <img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/GuMuFeng/picture/master/kalman/kalman_2.jpg"  width="300px"> </div><br>&emsp;&emsp;我们可能知道一些机器人如何运动的信息：例如，机器人知道发送给电机的指令，知道自己是否在朝一个方向移动并且没有人干预，在下一个状态，机器人很可能朝着相同的方向移动。当然，机器人对自己的运动是一无所知的：它可能受到风吹的影响，轮子可能会出现打滑，或者遇到不平的地面而翻倒。所以，轮子的转动量并不能精确表示机器人实际行走的距离，预测效果并不完美。<p>&emsp;&emsp;GPS传感器告诉了我们一些状态信息，但都是间接的，并伴随一些不确定性和不准确性，我们的<strong>预测</strong>告诉了我们机器人会怎样运动，但都只是间接的，并且伴随着一些不确定和不准确性。<br>&emsp;&emsp;但是，如果使用所有对我们可用的信息，我们能得到一个比任何依据自身估计更好的结果吗？回答当然是肯定的，这就是卡尔曼滤波的用处。</p><h2 id="如何用卡尔曼滤波看待你的问题"><a href="#如何用卡尔曼滤波看待你的问题" class="headerlink" title="如何用卡尔曼滤波看待你的问题"></a>如何用卡尔曼滤波看待你的问题</h2><p>&emsp;&emsp;下面我们继续以只有位置和速度这两个状态的简单例子做解释。<br> $$\vec{x} = \begin{bmatrix}p\v\end{bmatrix}$$<br>&emsp;&emsp;我们并不知道实际的位置和速度，它们之间有很多种可能正确的组合，但其中一些的可能性要大于其它部分：</p><div align="center"> <img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/GuMuFeng/picture/master/kalman/kalman_3.jpg" height="300px" width="300px"> </div><br><p>&emsp;&emsp;卡尔曼滤波假设两个变量（位置和速度，在这个例子中）都是随机的，并且服从<strong>高斯分布</strong>,每个变量都有一个均值$\mu$，表示随机分布的中心（最可能的状态），以及方差$\sigma^2$，表示不确定性：</p><div align="center"> <img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/GuMuFeng/picture/master/kalman/kalman_4.jpg" height="300px" width="300px"> </div><br><p>&emsp;&emsp;在上图中，位置和速度是不相关的，这意味着由其中一个变量的状态无法推测出另一个变量可能的值。<br>&emsp;&emsp;下面的例子更有趣：位置和速度是相关的，观测特定位置的可能性取决于当前的速度：</p><div align="center"> <img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/GuMuFeng/picture/master/kalman/kalman_5.jpg" height="300px" width="300px"> </div><br><p>&emsp;&emsp;这种情况是有可能发生的，例如，我们基于旧的位置来估计新位置。如果我们的速度很高，我们可能移动得更快，所以我们的位置会更远。如果缓慢移动，则距离不会很远。<br>&emsp;&emsp;跟踪这种关系是非常重要的，因为它可以提供给我们更多的信息：其中一个测量值告诉了我们其它变量可能的值，这就是卡尔曼滤波的目的，尽可能地在包含不确定性的测量数据中提取更多信息！<br>&emsp;&emsp;这种相关性用协方差矩阵$\Sigma$来表示。</p><!-- 简言之，矩阵中的每个元素$\Sigma_{i j}$表示第 $i$ 个和第 $j$ 个状态变量的相关度。&emsp;&emsp;(你可能已经猜到协方差矩阵是一个对称矩阵，这意味着交换$i$和$j$是没关系的)协方差矩阵通常用 $\Sigma$ 表示，其中的元素则用 $\Sigma_{ij}$ 表示。 --><div align="center"> <img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/GuMuFeng/picture/master/kalman/kalman_6.jpg" height="300px" width="300px"> </div><br><h2 id="使用矩阵来描述问题"><a href="#使用矩阵来描述问题" class="headerlink" title="使用矩阵来描述问题"></a>使用矩阵来描述问题</h2><p>&emsp;&emsp;我们基于高斯分布来建立状态变量，所以在时刻 $k$ 需要两个信息：最佳估计 $\hat{x_k}$(即均值，其他地方常用 $\mu$ 表示)以及协方差矩阵 $P_k$。<br> $$\hat{x_k} = \begin{bmatrix}position\velocity\end{bmatrix},<br> P_k=\begin{bmatrix}\Sigma_{pp} &amp; \Sigma_{pv} \\Sigma_{vp} &amp; \Sigma_{vv} \\end{bmatrix}$$<br>&emsp;&emsp;当然，在这里我们只用到了位置和速度，实际上这个状态可以包含多个变量，代表任何你想表示的信息。<br>&emsp;&emsp;接下来，我们需要根据当前状态（$k-1$ 时刻）来预测下一状态（$k$ 时刻）。记住，我们并不知道对下一状态的所有预测中哪个是“真实”的，但我们的预测函数并不在乎。它对所有的可能性进行预测，并给出新的高斯分布。</p><div align="center"> <img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/GuMuFeng/picture/master/kalman/kalman_7.jpg" height="300px" width="300px"> </div><br><p>&emsp;&emsp;我们可以用矩阵 $F_k$ 来表示这个预测过程：</p><div align="center"> <img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/GuMuFeng/picture/master/kalman/kalman_8.jpg" height="300px" width="300px"> </div><br><p>&emsp;&emsp;它将我们原始估计中的每个点都移动到了一个新的预测位置，如果原始估计是正确的话，这个新的预测位置就是系统下一步会移动到的位置。那我们又如何用矩阵来预测下一个时刻的位置和速度呢？我们用一个基本的运动学公式来表示：</p><p>$$ \begin{aligned} p_k &amp;= p_{k-1} + \Delta t v_{k-1} \ v_k &amp;= v_{k-1}\end{aligned} $$</p><p>&emsp;&emsp;换句话说：<br>$$<br>\begin{aligned}<br>\mathbf{\hat{x}}<em>k &amp;= \begin{bmatrix}<br>1 &amp; \Delta t \<br>0 &amp; 1<br>\end{bmatrix} \mathbf{\hat{x}}</em>{k-1} \<br>&amp;= \mathbf{F}<em>k \mathbf{\hat{x}}</em>{k-1}<br>\end{aligned}<br>$$</p><p>&emsp;&emsp;现在，我们有了一个预测矩阵来表示下一时刻的状态，但是我们仍然不知道如何更新协方差矩阵。此时，我们需要引入另一个公式，如果我们将分布中的每个点都乘以矩阵$A$,那么它的协方差矩阵$\mathbf{\Sigma}$会怎么变化呢？<br>&emsp;&emsp;很简单，下面给出公式：<br>$$<br>\begin{aligned}<br>Cov(x) &amp;= \Sigma\<br>Cov(\mathbf{A}x) &amp;= \mathbf{A} \Sigma \mathbf{A}^T<br>\end{aligned}<br>$$<br>&emsp;&emsp;结合上面两式可以得到：<br>$$<br>\begin{aligned}<br>\mathbf{\hat{x}}<em>k &amp;= \mathbf{F}<em>k \mathbf{\hat{x}}</em>{k-1} \<br>{\mathbf{P}_k} &amp;= \mathbf{F_k} {\mathbf{P}</em>{k-1}} \mathbf{F}<em>k^T<br>\end{aligned}<br>$$<br>##外因干扰<br>&emsp;&emsp;我们并没有捕捉到一切信息，可能存在外部因素影响系统，带来一些与系统自身状态无关的改变。<br>&emsp;&emsp;以火车的运动状态模型为例，火车司机可能会推动油门，让火车加速。相同地，在我们机器人这个例子中，导航软件可能会发出一个指令让轮子转向或者停止。如果知道这些额外的信息，我们可以用一个向量 $\vec{u_k}$ 描述来表示，将其加到我们的预测方程中做修正。<br>&emsp;&emsp;假设由于油门的设置或控制命令，我们知道了期望的加速度 $a$，根据基本的运动学方程可以得到：<br>$$<br>\begin{aligned}<br>{p_k} &amp;= {p</em>{k-1}} + {\Delta t} {v_{k-1}} + \frac{1}{2} {a} {\Delta t}^2 \<br>{v_k} &amp;= {v_{k-1}} +  {a} {\Delta t}<br>\end{aligned}<br>$$<br>&emsp;&emsp;用矩阵的形式表示：</p><p>$$<br>\begin{aligned}<br>{\mathbf{\hat{x}}_k} &amp;= \mathbf{F}<em>k {\mathbf{\hat{x}}</em>{k-1}} + \begin{bmatrix}<br>\frac{\Delta t^2}{2} \<br>\Delta t<br>\end{bmatrix} {a} \<br>&amp;= \mathbf{F}<em>k {\mathbf{\hat{x}}</em>{k-1}} + \mathbf{B}_k {\vec{\mathbf{u}_k}}<br>\end{aligned}<br>$$<br>&emsp;&emsp;$\mathbf{B}_k$称之为控制矩阵，${\vec{\mathbf{u}_k}}$ 称之为控制向量。（对于没有外部干扰的简单系统来说，这部分可以忽略）。让我们再思考一下，如果我们的预测并不是100%准确的，该怎么办呢？</p><h2 id="外部不确定性"><a href="#外部不确定性" class="headerlink" title="外部不确定性"></a>外部不确定性</h2><p>&emsp;&emsp;如果这些状态量是基于系统自身的属性变化的或者如果状态量根据外部干扰变化，只要我们知道这些外部干扰是什么，就可以了。<br>&emsp;&emsp;但是，我们外部干扰未知呢？例如，假设我们跟踪一个四旋翼飞行器，它可能会受到风的干扰，如果我们跟踪一个轮式机器人，轮子可能会打滑，或者路面上的崎岖会让它减速。这样的话我们就不能继续对这些状态进行跟踪，如果没有把这些外部干扰考虑在内，我们的预测就会出现偏差。<br>&emsp;&emsp;通过在每次预测之后添加一些新的不确定性，我们可以添加一些新的不确定性来建立这种与“外界”（即我们没有跟踪的干扰）之间的不确定性模型：</p><div align="center"> <img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/GuMuFeng/picture/master/kalman/kalman_9.jpg" height="300px" width="300px"> </div><br><p>&emsp;&emsp;原始估计中的每个状态变量更新到新的状态后，仍然服从高斯分布。我们可以说$\hat{x}_{k-1}$的每个状态变量移动到了一个新的服从高斯分布的区域，协方差为$Q_k$,换句话说就是，我们将这些没有被跟踪的干扰当作协方差为$Q_k$的噪声来处理。</p><div align="center"> <img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/GuMuFeng/picture/master/kalman/kalman_10.jpg" height="300px" width="300px"> </div><br><p>&emsp;&emsp;这产生了具有不同协方差（但是具有相同的均值）的新的高斯分布。</p><div align="center"> <img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/GuMuFeng/picture/master/kalman/kalman_11.jpg" height="300px" width="300px"> </div><br><p>&emsp;&emsp;我们可以通过简单地添加$Q_k$得到扩展的协方差，下面为预测步骤提供完整的表达式：<br>$$<br>\begin{aligned}<br>{\mathbf{\hat{x}}<em>k} &amp;= \mathbf{F}<em>k {\mathbf{\hat{x}}</em>{k-1}} + \mathbf{B}_k {\vec{\mathbf{u}_k}} \<br>{\mathbf{P}_k} &amp;= \mathbf{F_k} {\mathbf{P}</em>{k-1}} \mathbf{F}_k^T + {\mathbf{Q}_k}<br>\end{aligned}<br>$$<br>&emsp;&emsp;换句话说，新的最佳估计是根据先前的最佳估计做出的预测，再加上对已知外部影响的修正。新的不确定性是根据上一不确定性来预测的，而外部环境还会带来其他一些不确定性。<br>&emsp;&emsp;好了，我们对系统可能位于的位置有一个模糊的估计，用 $x_k$ 和 $p_k$ 表示。当我们从传感器中获取一些数据时会发生什么？</p><h2 id="用测量值来修正估计值"><a href="#用测量值来修正估计值" class="headerlink" title="用测量值来修正估计值"></a>用测量值来修正估计值</h2><p>&emsp;&emsp;我们可能有几个传感器，这些传感器可以向我们提供有关系统状态的信息。哪个传感器具体测量的是哪个状态变量并不重要。也许一个读取位置，另一个读取速度。每个传感器都间接告诉我们有关状态的一些信息，换句话说，传感器在状态下运行并产生一组读数。</p><div align="center"> <img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/GuMuFeng/picture/master/kalman/kalman_12.jpg" height="300px" width="500px"> </div><br><p>&emsp;&emsp;请注意，读数的单位和小数位数可能与我们跟踪的状态的单位和小数位数不同。你也许能够猜出应该怎么处理：我们用矩阵 $H_k$ 对传感器建模。</p><div align="center"> <img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/GuMuFeng/picture/master/kalman/kalman_13.jpg" height="300px" width="500px"> </div><br><p>&emsp;&emsp;我们可以计算出传感器读数的分布，用之前的表示方法如下式所示：<br>$$<br>\begin{aligned}<br>\vec{\mu}<em>{\text{expected}} &amp;= \mathbf{H}_k {\mathbf{\hat{x}}_k} \<br>\mathbf{\Sigma}</em>{\text{expected}} &amp;= \mathbf{H}_k {\mathbf{P}_k} \mathbf{H}_k^T<br>\end{aligned}<br>$$<br>&emsp;&emsp;卡尔曼滤波器最适合做的一件事是处理传感器噪声。换句话说，我们的传感器或多或少有些不可靠，并且我们原始估计中的每个状态可以和一定范围内的传感器读数对应起来。</p><div align="center"> <img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/GuMuFeng/picture/master/kalman/kalman_14.jpg" height="300px" width="500px"> </div><br><p>&emsp;&emsp;从测量到的传感器数据中，我们大致能猜到系统当前处于什么状态。但是由于存在不确定性，某些状态可能比我们得到的读数更接近真实状态。</p><div align="center"> <img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/GuMuFeng/picture/master/kalman/kalman_15.jpg" height="300px" width="300px"> </div><br><p>&emsp;&emsp;我们将这种不确定性（例如：传感器噪声）用协方差 $R_k$ 表示，该分布的均值就是我们读取到的传感器数据，称之为 $\vec{z_k}$。现在我们有了两个高斯分布，一个是在预测值附近，一个是在传感器读数附近。</p><div align="center"> <img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/GuMuFeng/picture/master/kalman/kalman_16.jpg" height="300px" width="300px"> </div><br><p>&emsp;&emsp;我们必须在预测值（粉红色）和传感器测量值（绿色）之间找到最优解。<br>&emsp;&emsp;那么，我们最有可能的状态是什么呢？对于任何可能的读数 $(z_1,z_2)$,有两种相关的概率：（1）传感器的测量值；（2）由前一状态得到的预测值。如果我们想知道这两种情况都可能发生的概率，将这两个高斯分布相乘就可以了。</p><div align="center"> <img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/GuMuFeng/picture/master/kalman/kalman_17.jpg" height="300px" width="300px"> </div><br><p>&emsp;&emsp;剩下的就是重叠部分了，这个重叠部分的均值就是两个估计最可能的值，也就是给定的所有信息中的最优估计。这个重叠的区域看起来像另一个高斯分布。</p><div align="center"> <img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/GuMuFeng/picture/master/kalman/kalman_18.jpg" height="300px"width="300px"> </div><br><p>&emsp;&emsp;事实证明，当你将两个不同均值和协方差的高斯分布相乘时，将会得到一个新的具有独立均值和方差的高斯分布！</p><h2 id="融合高斯分布"><a href="#融合高斯分布" class="headerlink" title="融合高斯分布"></a>融合高斯分布</h2><p>&emsp;&emsp;先以简单的一维高斯分布来分析，具有方差 $\sigma^2$ 和均值 $\mu$ 的高斯曲线可以用下式表示:<br>$$<br>\mathcal{N}(x, \mu,\sigma) = \frac{1}{ \sigma \sqrt{ 2\pi } } e^{ -\frac{ (x – \mu)^2 }{ 2\sigma^2 } }<br>$$<br>&emsp;&emsp;如果把两个服从高斯分布的函数相乘会得到什么呢？下面的蓝色曲线代表两个高斯总体的（未归一化）交集：</p><div align="center"> <img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/GuMuFeng/picture/master/kalman/kalman_19.jpg" height="300px"width="300px"> </div><br><p>$$<br>\mathcal{N}(x, {\mu_0}, {\sigma_0}) \cdot \mathcal{N}(x, {\mu_1}, {\sigma_1}) \stackrel{?}{=} \mathcal{N}(x, {\mu’}, {\sigma’})<br>$$<br>&emsp;&emsp;联立上面两式（注意重新归一化，使总概率为1）可以得到：<br>$$<br>\begin{aligned}<br>\color{royalblue}{\mu’} &amp;= \mu_0 + \frac{\sigma_0^2 (\mu_1 – \mu_0)} {\sigma_0^2 + \sigma_1^2}\<br>\color{mediumblue}{\sigma’}^2 &amp;= \sigma_0^2 – \frac{\sigma_0^4} {\sigma_0^2 + \sigma_1^2}<br>\end{aligned}$$<br>&emsp;&emsp;可以用 $k$来代替上式中相同的部分进行简化。<br>$$<br>\begin{aligned}<br>{\mathbf{k}} = \frac{\sigma_0^2}{\sigma_0^2 + \sigma_1^2}\<br>\end{aligned}<br>$$</p><p>$$<br>\begin{aligned}<br>{\mu’} &amp;= \mu_0 + {\mathbf{k}} (\mu_1 – \mu_0)\<br>{\sigma’}^2 &amp;= \sigma_0^2 – {\mathbf{k}} \sigma_0^2<br>\end{aligned}<br>$$<br>&emsp;&emsp;将上面两式写成矩阵的形式,如果 $\Sigma$ 表示高斯分布的协方差，$\vec{\mu}$ 表示每个维度的均值，则：<br>$$<br>{\mathbf{K}} = \Sigma_0 (\Sigma_0 + \Sigma_1)^{-1}<br>$$</p><p>$$<br>\begin{aligned}<br>{\vec{\mu}’} &amp;= \vec{\mu_0} + {\mathbf{K}} (\vec{\mu_1} – \vec{\mu_0})\<br>{\Sigma’} &amp;= \Sigma_0 – {\mathbf{K}} \Sigma_0<br>\end{aligned}<br>$$<br>&emsp;&emsp;矩阵 $K$ 称为卡尔曼增益。</p><h2 id="整合所有公式"><a href="#整合所有公式" class="headerlink" title="整合所有公式"></a>整合所有公式</h2><p>&emsp;&emsp;我们有两个高斯分布，预测部分 $(\color{fuchsia}{\mu_0}, \color{deeppink}{\Sigma_0}) = (\color{fuchsia}{\mathbf{H}_k \mathbf{\hat{x}}_k}, \color{deeppink}{\mathbf{H}_k \mathbf{P}_k \mathbf{H}_k^T})$ 和测量部分 $(\color{yellowgreen}{\mu_1}, \color{mediumaquamarine}{\Sigma_1}) = (\color{yellowgreen}{\vec{\mathbf{z}_k}}, \color{mediumaquamarine}{\mathbf{R}_k})$。将它们带入上式，计算重叠部分：<br>$$<br>\begin{aligned}<br>\mathbf{H}_k{\mathbf{\hat{x}}_k’} &amp;={\mathbf{H}_k \mathbf{\hat{x}}_k}  +  {\mathbf{K}} ( {\vec{\mathbf{z}_k}} – {\mathbf{H}_k \mathbf{\hat{x}}_k} ) \<br>\mathbf{H}_k {\mathbf{P}_k’} \mathbf{H}_k^T &amp;= {\mathbf{H}_k \mathbf{P}_k \mathbf{H}_k^T}  –  {\mathbf{K}} {\mathbf{H}_k \mathbf{P}_k \mathbf{H}_k^T}<br>\end{aligned}<br>$$<br>&emsp;&emsp;卡尔曼增益为：<br>$$<br>{\mathbf{K}} ={\mathbf{H}_k \mathbf{P}_k \mathbf{H}_k^T} ( {\mathbf{H}_k \mathbf{P}_k \mathbf{H}_k^T} + {\mathbf{R}_k})^{-1}<br>$$<br>&emsp;&emsp;将上面两式进行联立化简，可以得到：<br>$$<br>\begin{aligned}<br>\color{royalblue}{\mathbf{\hat{x}}_k’} &amp;= \color{fuchsia}{\mathbf{\hat{x}}_k}  +  \color{purple}{\mathbf{K}’} ( \color{yellowgreen}{\vec{\mathbf{z}_k}} – \color{fuchsia}{\mathbf{H}_k \mathbf{\hat{x}}_k} )\<br>\color{royalblue}{\mathbf{P}_k’} &amp;= \color{deeppink}{\mathbf{P}_k}  –  \color{purple}{\mathbf{K}’} \color{deeppink}{\mathbf{H}_k \mathbf{P}_k}<br>\end{aligned}<br>$$</p><p>$$<br>\color{purple}{\mathbf{K}’} = \color{deeppink}{\mathbf{P}_k \mathbf{H}_k^T} ( \color{deeppink}{\mathbf{H}_k \mathbf{P}_k \mathbf{H}_k^T} + \color{mediumaquamarine}{\mathbf{R}_k})^{-1}<br>$$ </p><p>&emsp;&emsp;上面方程式给出了完整的更新步骤。$\hat{x_k’}$ 就是新的最优估计，我们可以将它和 $\hat{P_k’}$ 放到下一个预测和更新方程中不断迭代。</p><div align="center"> <img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/GuMuFeng/picture/master/kalman/kalman_20.jpg" height="300px"width="300px"> </div><br>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法之双指针问题</title>
      <link href="/2020/02/21/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98/"/>
      <url>/2020/02/21/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="双指针问题"><a href="#双指针问题" class="headerlink" title="双指针问题"></a>双指针问题</h1><p>什么是<strong>双指针</strong>?<br>&emsp;&emsp;双指针，指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向（快慢指针）或者相反方向（对撞指针）的指针进行扫描，从而达到相应的目的算法。<br>&emsp;&emsp;双指针法充分使用了数组有序这一特征，从而在某些情况下能够简化一些运算。</p><hr><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>&emsp; &emsp;快慢指针中的快慢指的是移动的步长，即指针每次向前移动速度的快慢。例如可以让快指针每次沿链表向前移动2，慢指针每次向前移动1次。利用快慢指针可以用来解决某些算法问题，比如</p><ul><li><p>计算链表的中点：快慢指针从头节点出发，每轮迭代中，快指针向前移动两个节点，慢指针向前移动一个节点，最终当快指针到达终点的时候，慢指针刚好在中间的节点。</p></li><li><p>判断链表是否有环：如果链表中存在环，则在链表上不断前进的指针会一直在环里绕圈子，且不能知道链表是否有环。使用快慢指针，当链表中存在环时，两个指针最终会在环中相遇。</p></li><li><p>判断链表中环的起点：当我们判断出链表中存在环，并且知道了两个指针相遇的节点，我们可以让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。</p></li><li><p>求链表中环的长度：只要相遇后一个不动，另一个前进直到相遇算一下走了多少步就好了.</p></li><li><p>求链表倒数第k个元素：先让其中一个指针向前走k步，接着两个指针以同样的速度一起向前进，直到前面的指针走到尽头了，则后面的指针即为倒数第k个元素。（严格来说应该叫先后指针而非快慢指针）.</p></li></ul><hr><h2 id="碰撞指针"><a href="#碰撞指针" class="headerlink" title="碰撞指针"></a>碰撞指针</h2><p>&emsp;&emsp;一般都是排好序的数组或链表，否则无序的话这两个指针的位置也没有什么意义。特别注意两个指针的循环条件在循环体中的变化，小心右指针跑到左指针左边去了。常用来解决的问题有</p><ul><li><p>二分查找问题；</p></li><li><p>n数之和问题，比如两数之和问题，先对数组排序然后左右指针找到满足条件的两个数，如果是三数问题就转化为一个数和另外两个数的两数问题，以此类推；</p></li><li><p>反转数组；</p></li><li><p>滑动窗口法，比如解决一大类子字符串匹配。</p></li></ul><hr><h2 id="LeetCode相关题目"><a href="#LeetCode相关题目" class="headerlink" title="LeetCode相关题目"></a>LeetCode相关题目</h2><ul><li><a href="#1-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C">1. 有序数组的两数之和</a></li><li><a href="#2-%E4%B8%A4%E6%95%B0%E5%B9%B3%E6%96%B9%E5%92%8C">2. 两数平方和</a></li><li><a href="#3-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E7%AC%A6">3. 反转字符串中的元音字符</a></li><li><a href="#4-%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2">4. 回文字符串</a></li><li><a href="#5-%E5%BD%92%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84">5. 归并两个有序数组</a></li><li><a href="#6-%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E7%8E%AF">6. 判断链表是否存在环</a></li><li><a href="#7-%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97">7. 最长子序列</a></li></ul><h3 id="1-有序数组的两数之和"><a href="#1-有序数组的两数之和" class="headerlink" title="1. 有序数组的两数之和"></a>1. 有序数组的两数之和</h3><p>167. 两数之和II - 输入有序数组(简单)</p><p><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/">Leetcode</a> / <a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/description/">力扣</a></p><blockquote><p><font color=orange >题目描述：<br>&emsp;&emsp;给定一个已按照升序排列的有序数组，找到两个数使得它们相加之和等于目标数。函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。返回的下标值（index1 和 index2）不是从零开始的。你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</font></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: numbers=&#123;2, 7, 11, 15&#125;, target=9</span><br><span class="line">输出: index1=1, index2=2</span><br></pre></td></tr></table></figure><p>使用双指针，一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。</p><ul><li>如果两个指针指向元素的和 sum == target，那么得到要求的结果；</li><li>如果 sum &gt; target，移动较大的元素，使 sum 变小一些；</li><li>如果 sum &lt; target，移动较小的元素，使 sum 变大一些。</li></ul><p>数组中的元素最多遍历一次，时间复杂度为 O(N)。只使用了两个额外变量，空间复杂度为  O(1)。</p><!--<div align="center"> <img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/GuMuFeng/picture/master/two_sum.gif" width="200px"> </div><br>--><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++暴力解法，两个for循环遍历数组，时间复杂度为O(n^2),容易超出运行时间限制。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;nums.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)</span><br><span class="line">                &#123;</span><br><span class="line">                   <span class="keyword">return</span> &#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;i,j&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++双指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = numbers[low] + numbers[high];</span><br><span class="line">            <span class="keyword">if</span> (sum == target)</span><br><span class="line">                <span class="keyword">return</span> &#123;low + <span class="number">1</span>, high + <span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target)</span><br><span class="line">                ++low;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                --high;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//python</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twosum</span>(<span class="params">self,numbers,target</span>):</span></span><br><span class="line">    satrt = <span class="number">0</span></span><br><span class="line">    end = len(numbers)<span class="number">-1</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    whie start != end:</span><br><span class="line">        sum = numbers[start]+numbers[end]</span><br><span class="line">        <span class="keyword">if</span> sum &gt; target:</span><br><span class="line">            end -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> sum &lt; target:</span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> [start+<span class="number">1</span>,end+<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="2-两数平方和"><a href="#2-两数平方和" class="headerlink" title="2. 两数平方和"></a>2. 两数平方和</h3><p>633. 平方数之和(简单)</p><p><a href="https://leetcode.com/problems/sum-of-square-numbers/description/">Leetcode</a> / <a href="https://leetcode-cn.com/problems/sum-of-square-numbers/description/">力扣</a></p><blockquote><p><font color=orange >题目描述：<br>&emsp;&emsp;给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a^2 + b^2 = c。</font></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: True</span><br><span class="line">解释: 1 * 1 + 2 * 2 = 5</span><br></pre></td></tr></table></figure><p>可以看成是在元素为 0~target 的有序数组中查找两个数，使得这两个数的平方和为 target，如果能找到，则返回 true，表示 target 是两个整数的平方和。</p><p>本题和 167. 两数之和II类似，只有一个明显区别：一个是和为 target，一个是平方和为 target。本题同样可以使用双指针得到两个数，使其平方和为 target。</p><p>本题的关键是右指针的初始化，实现剪枝，从而降低时间复杂度。设右指针为 x，左指针固定为 0，为了使 0<sup>2</sup> + x<sup>2</sup> 的值尽可能接近 target，我们可以将 x 取为 sqrt(target)。</p><p>因为最多只需要遍历一次 0~sqrt(target)，所以时间复杂度为 O(sqrt(target))。又因为只使用了两个额外的变量，因此空间复杂度为 O(1)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++双指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c &lt; <span class="number">0</span> )</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> a=<span class="built_in">sqrt</span>(c);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> low =<span class="number">0</span>,high = a;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">            sum = low * low + high * high;</span><br><span class="line">            <span class="keyword">if</span>(sum == c)</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; c)</span><br><span class="line">               ++low;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">               --high;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java 双指针</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (target &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>, j = (<span class="keyword">int</span>) Math.sqrt(target);</span><br><span class="line">     <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">         <span class="keyword">int</span> powSum = i * i + j * j;</span><br><span class="line">         <span class="keyword">if</span> (powSum == target) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (powSum &gt; target) &#123;</span><br><span class="line">             j--;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             i++;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="3-反转字符串中的元音字符"><a href="#3-反转字符串中的元音字符" class="headerlink" title="3. 反转字符串中的元音字符"></a>3. 反转字符串中的元音字符</h3><p>345. Reverse Vowels of a String (Easy)</p><p><a href="https://leetcode.com/problems/reverse-vowels-of-a-string/description/">Leetcode</a> / <a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/description/">力扣</a></p><blockquote><p><font color=orange >题目描述：<br>&emsp;&emsp;编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</font></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: leetcode</span><br><span class="line">输出: leotcede</span><br></pre></td></tr></table></figure><!--<div align="center"> <img src= "/img/loading.gif" data-lazy-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a7cb8423-895d-4975-8ef8-662a0029c772.png" width="400px"> </div><br>--><p>使用双指针，一个指针从头向尾遍历，一个指针从尾到头遍历，当两个指针都遍历到元音字符时，交换这两个元音字符。</p><p>为了快速判断一个字符是不是元音字符，我们将全部元音字符添加到集合 HashSet 中，从而以 O(1) 的时间复杂度进行该操作。</p><ul><li>时间复杂度为 O(N)：只需要遍历所有元素一次</li><li>空间复杂度 O(1)：只需要使用两个额外变量</li></ul><!--<div align="center"> <img src= "/img/loading.gif" data-lazy-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ef25ff7c-0f63-420d-8b30-eafbeea35d11.gif" width="400px"> </div><br>--><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseVowels</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> vowels = <span class="string">&quot;AaEeIiOoUu&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vowels.<span class="built_in">find</span>(s[i]) !=<span class="built_in">string</span>::npos  &amp;&amp; vowels.<span class="built_in">find</span>(s[j]) != <span class="built_in">string</span>::npos) &#123;</span><br><span class="line">                swap(s[i], s[j]);</span><br><span class="line">                i++, j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (vowels.<span class="built_in">find</span>(s[i]) !=<span class="built_in">string</span>::npos  &amp;&amp; vowels.<span class="built_in">find</span>(s[j])== <span class="built_in">string</span>::npos)</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (vowels.<span class="built_in">find</span>(s[i]) == <span class="built_in">string</span>::npos &amp;&amp; vowels.<span class="built_in">find</span>(s[j]) != <span class="built_in">string</span>::npos)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i++,j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isOrigin</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;a&#x27;</span> || c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;i&#x27;</span> || c == <span class="string">&#x27;o&#x27;</span> || c == <span class="string">&#x27;u&#x27;</span> || </span><br><span class="line">            c == <span class="string">&#x27;A&#x27;</span> || c == <span class="string">&#x27;E&#x27;</span> || c == <span class="string">&#x27;I&#x27;</span> || c == <span class="string">&#x27;O&#x27;</span> || c == <span class="string">&#x27;U&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseVowels</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isOrigin(s[i]))&#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!isOrigin(s[j]))&#123;</span><br><span class="line">                j--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(s[i++],s[j--]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HashSet&lt;Character&gt; vowels = <span class="keyword">new</span> HashSet&lt;&gt;(</span><br><span class="line">        Arrays.asList(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;U&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>[] result = <span class="keyword">new</span> <span class="keyword">char</span>[s.length()];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="keyword">char</span> ci = s.charAt(i);</span><br><span class="line">        <span class="keyword">char</span> cj = s.charAt(j);</span><br><span class="line">        <span class="keyword">if</span> (!vowels.contains(ci)) &#123;</span><br><span class="line">            result[i++] = ci;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!vowels.contains(cj)) &#123;</span><br><span class="line">            result[j--] = cj;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result[i++] = cj;</span><br><span class="line">            result[j--] = ci;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-回文字符串"><a href="#4-回文字符串" class="headerlink" title="4. 回文字符串"></a>4. 回文字符串</h3><p>680. 验证回文字符串 Ⅱ (简单)</p><p><a href="https://leetcode.com/problems/valid-palindrome-ii/description/">Leetcode</a> / <a href="https://leetcode-cn.com/problems/valid-palindrome-ii/description/">力扣</a></p><blockquote><p><font color=orange >题目描述：<br>&emsp;&emsp;给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。</font></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abca&quot;</span><br><span class="line">输出: True</span><br><span class="line">解释: 你可以删除字符&#x27;c&#x27;或者&#x27;d&#x27;.</span><br></pre></td></tr></table></figure><p>所谓的回文字符串，是指具有左右对称特点的字符串，例如 “abcba” 就是一个回文字符串。</p><p>使用双指针可以很容易判断一个字符串是否是回文字符串：令一个指针从左到右遍历，一个指针从右到左遍历，这两个指针同时移动一个位置，每次都判断两个指针指向的字符是否相同，如果都相同，字符串才是具有左右对称性质的回文字符串。</p><!--<div align="center"> <img src= "/img/loading.gif" data-lazy-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/fcc941ec-134b-4dcd-bc86-1702fd305300.gif" width="250px"> </div><br>--><p>本题的关键是处理删除一个字符。在使用双指针遍历字符串时，如果出现两个指针指向的字符不相等的情况，我们就试着删除一个字符，再判断删除完之后的字符串是否是回文字符串。</p><p>在判断是否为回文字符串时，我们不需要判断整个字符串，因为左指针左边和右指针右边的字符之前已经判断过具有对称性质，所以只需要判断中间的子字符串即可。</p><p>在试着删除字符时，我们既可以删除左指针指向的字符，也可以删除右指针指向的字符。</p><!--<div align="center"> <img src= "/img/loading.gif" data-lazy-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/db5f30a7-8bfa-4ecc-ab5d-747c77818964.gif" width="300px"> </div><br>--><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[left] != s[right])</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">isValid</span>(s, left, right - <span class="number">1</span>) || <span class="built_in">isValid</span>(s, left + <span class="number">1</span>, right);</span><br><span class="line">            ++left;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[left] != s[right])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            ++left;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//python</span><br><span class="line">classs Solution:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span>(<span class="params">self,s</span>):</span></span><br><span class="line">        i,j=<span class="number">0</span>,len(s)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> s[i] != s[j]:</span><br><span class="line">                <span class="keyword">return</span> self.isPalindrome(s,i+<span class="number">1</span>,j) <span class="keyword">or</span> self.isPalindrome(s,i,j<span class="number">-1</span>)</span><br><span class="line">            i+=<span class="number">1</span> <span class="comment">#python自增没有++只有+=；</span></span><br><span class="line">            j-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self,s,i,j</span>):</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> s[i]==s[j]:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//python</span><br><span class="line">classs Solution:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span>(<span class="params">self,s</span>):</span></span><br><span class="line">        i,j = <span class="number">0</span>,len(s)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> s[i] != s[j]:</span><br><span class="line">                a=[i+<span class="number">1</span>:j+<span class="number">1</span>]</span><br><span class="line">                b=[i,j]</span><br><span class="line">                <span class="keyword">return</span> a[::<span class="number">-1</span>] == a <span class="keyword">or</span> b[::<span class="number">-1</span>] == b</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">            j-=<span class="number">1</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = s.length() - <span class="number">1</span>; i &lt; j; i++, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) != s.charAt(j)) &#123;</span><br><span class="line">            <span class="keyword">return</span> isPalindrome(s, i, j - <span class="number">1</span>) || isPalindrome(s, i + <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i++) != s.charAt(j--)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-合并两个有序数组"><a href="#5-合并两个有序数组" class="headerlink" title="5. 合并两个有序数组"></a>5. 合并两个有序数组</h3><p>88. 合并两个有序数组（简单）</p><p><a href="https://leetcode.com/problems/merge-sorted-array/description/">Leetcode</a> / <a href="https://leetcode-cn.com/problems/merge-sorted-array/description/">力扣</a></p><blockquote><p><font color=orange >题目描述：<br>&emsp;&emsp;给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。<br>&emsp;&emsp;说明:初始化 nums1 和 nums2 的元素数量分别为 m 和 n；你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</font></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line">输出: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><p>需要从尾开始遍历，否则在 nums1 上归并得到的值会覆盖还未进行归并比较的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//python</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self,nums1,m,nums2,n</span>):</span></span><br><span class="line">        <span class="keyword">while</span> m &gt; <span class="number">0</span> <span class="keyword">and</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[m<span class="number">-1</span>] &lt; nums2[n<span class="number">-1</span>]:</span><br><span class="line">                nums1[m<span class="number">-1</span>+n] = nums[n<span class="number">-1</span>]</span><br><span class="line">                n-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[m<span class="number">-1</span>],nums1[m<span class="number">-1</span>+n] = nums1[m<span class="number">-1</span>+n],nums1[m<span class="number">-1</span>]</span><br><span class="line">                m-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span> <span class="keyword">and</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            nums1[:n] = nums2[:n]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(m &gt; <span class="number">0</span> &amp;&amp; n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[m<span class="number">-1</span>] &lt; nums2[n<span class="number">-1</span>])&#123;</span><br><span class="line">                nums1[m<span class="number">-1</span>+n] = nums2[n<span class="number">-1</span>];</span><br><span class="line">                n--;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">            &#123;</span><br><span class="line">                nums1[m<span class="number">-1</span>+n] = nums2[n<span class="number">-1</span>];</span><br><span class="line">                swap(nums1[m<span class="number">-1</span>+n],nums1[m<span class="number">-1</span>]);</span><br><span class="line">                m--;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(m == <span class="number">0</span> &amp;&amp; n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            nums1[n<span class="number">-1</span>] = nums2[n<span class="number">-1</span>];</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index1 = m - <span class="number">1</span>, index2 = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> indexMerge = m + n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (index1 &gt;= <span class="number">0</span> || index2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[indexMerge--] = nums2[index2--];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[indexMerge--] = nums1[index1--];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[index1] &gt; nums2[index2]) &#123;</span><br><span class="line">            nums1[indexMerge--] = nums1[index1--];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[indexMerge--] = nums2[index2--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-判断链表是否存在环"><a href="#6-判断链表是否存在环" class="headerlink" title="6. 判断链表是否存在环"></a>6. 判断链表是否存在环</h3><p>141. 环形链表（简单）</p><p><a href="https://leetcode.com/problems/linked-list-cycle/description/">Leetcode</a> / <a href="https://leetcode-cn.com/problems/linked-list-cycle/description/">力扣</a></p><blockquote><p><font color=orange >题目描述：<br>&emsp;&emsp;给定一个链表，判断链表中是否有环。<br>&emsp;&emsp;为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</font></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [3,2,0,-4], pos = 1</span><br><span class="line">输出: true</span><br><span class="line">解释: 链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;输入并没有pos，只有head,通过pos来判断是否存在环，pos就是tail相连的位置。<br>&emsp;&emsp;使用双指针，快慢指针，一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//python</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; bool:</span></span><br><span class="line">        slow,fast=head,head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            slow = slow.next</span><br><span class="line">            <span class="keyword">if</span> fast ==slow:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast=head;</span><br><span class="line">        ListNode *slow=head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode l1 = head, l2 = head.next;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span> &amp;&amp; l2.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == l2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">        l2 = l2.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-最长子序列"><a href="#7-最长子序列" class="headerlink" title="7. 最长子序列"></a>7. 最长子序列</h3><p>524. 通过删除字母匹配到字典里最长单词(中等)</p><p><a href="https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/description/">Leetcode</a> / <a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/description/">力扣</a></p><blockquote><p><font color=orange >题目描述：<br>&emsp;&emsp;给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。<br>说明:<br>&emsp;&emsp;所有输入的字符串只包含小写字母。<br>&emsp;&emsp;字典的大小不会超过 1000。<br>&emsp;&emsp;所有输入的字符串长度不会超过 1000。</font></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入:s = &quot;abpcplea&quot;, d = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]</span><br><span class="line">输出:&quot;apple&quot;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入:s = &quot;abpcplea&quot;, d = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br><span class="line">输出: &quot;a&quot;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;遍历字典，对于长度长于符合条件的最长子串的长度，或长度相等且字典序小于其的字符串，与给定字符串进行比对，若满足条件，则成为新的最长子串，直至扫描字典完毕。<br>&emsp;&emsp;双指针，字符串一个指针，字典成员一个指针，进行比较。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//python</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findLongestWord</span>(<span class="params">self, s, d</span>):</span></span><br><span class="line">    d.sort(key=<span class="keyword">lambda</span> x: (-len(x), x))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubseq</span>(<span class="params">word, s</span>):</span></span><br><span class="line">      i = <span class="number">0</span></span><br><span class="line">      <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> c == word[i]:</span><br><span class="line">          i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i == len(word):</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> d:</span><br><span class="line">      <span class="keyword">if</span> isSubseq(word, s):</span><br><span class="line">        <span class="keyword">return</span> word</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">findLongestWord</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> longestwordnow = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> member : d)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(longestwordnow.length() &lt; member.length() || (longestwordnow.length() ==member.length()) &amp;&amp; (longestwordnow.compare(member) &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; s.length() &amp;&amp; j &lt; member.length())&#123;</span><br><span class="line">                    <span class="keyword">if</span> (s[i] == member[j])</span><br><span class="line">                    j++;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == member.length())</span><br><span class="line">            longestwordnow = member;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longestwordnow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findLongestWord</span><span class="params">(String s, List&lt;String&gt; d)</span> </span>&#123;</span><br><span class="line">    String longestWord = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (String target : d) &#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = longestWord.length(), l2 = target.length();</span><br><span class="line">        <span class="keyword">if</span> (l1 &gt; l2 || (l1 == l2 &amp;&amp; longestWord.compareTo(target) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isSubstr(s, target)) &#123;</span><br><span class="line">            longestWord = target;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> longestWord;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSubstr</span><span class="params">(String s, String target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; j &lt; target.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == target.charAt(j)) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j == target.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> C++ </tag>
            
            <tag> python </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python切片操作</title>
      <link href="/2020/02/20/python%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/02/20/python%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="python切片操作"><a href="#python切片操作" class="headerlink" title="python切片操作"></a>python切片操作</h1><h2 id="python可切片对象的索引方式"><a href="#python可切片对象的索引方式" class="headerlink" title="python可切片对象的索引方式"></a>python可切片对象的索引方式</h2><p>&emsp;&emsp;python可切片对象的索引方式包括：<strong>正索引</strong>和<strong>负索引</strong>两部分。<br>&emsp;&emsp;以 a=[0,1,2,3,4,5,6,7,8,9]为例，如图所示：</p><div align="center"> <img src= "/img/loading.gif" data-lazy-src="https://imgkr.cn-bj.ufileos.com/85d3bcb9-79e3-4602-960f-578207867887.jpg" width="600px"> </div><br><h2 id="python切片操作的方式"><a href="#python切片操作的方式" class="headerlink" title="python切片操作的方式"></a>python切片操作的方式</h2><p>&emsp;&emsp;一个完整的切片表达式包含两个“:”，用于分隔三个参数（start_index、end_index、step），当只有一个“:”时，默认第三个参数step=1。</p><blockquote><p><font color=orange>切片的基本操作表达式为:<br>object[start_index : end_index : step]</font></p></blockquote><ul><li>step：正负数均可，其绝对值大小决定了切取数据时的“步长”，而正负号决定了“切取方向”，正表示“从左往右”取值，负表示“从右往左”取值。当step省略时，默认为1，即从左往右以增量1取值。“切取方向非常重要！”“切取方向非常重要！”“切取方向非常重要！”，重要的事情说三遍！</li><li>start_index：表示起始索引（包含该索引本身）；该参数省略时，表示从对象“端点”开始取值，至于是从“起点”还是从“终点”开始，则由step参数的正负决定，step为正从“起点”开始，为负从“终点”开始。</li><li>end_index：表示终止索引（不包含该索引本身）；该参数省略时，表示一直取到数据”端点“，至于是到”起点“还是到”终点“，同样由step参数的正负决定，step为正时直到”终点“，为负时直到”起点“。</li></ul><h2 id="python切片操作的详细例子"><a href="#python切片操作的详细例子" class="headerlink" title="python切片操作的详细例子"></a>python切片操作的详细例子</h2><p>&emsp;&emsp;以下操作均以列表a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]为例。</p><ul><li><p>1.切取单个值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>]</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">-4</span>]</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure></li><li><p>2.切取完整对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[:] <span class="comment"># 从左往右</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[::] <span class="comment"># 从左往右</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[::<span class="number">-1</span>] <span class="comment"># 从右往左</span></span><br><span class="line">[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure></li><li><p>3.start_index和end_index全为正（+）索引的情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>:<span class="number">6</span>] <span class="comment"># step=1，从左往右取值，start_index=1到end_index=6同样表示从左往右取值。</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;a[<span class="number">1</span>:<span class="number">6</span>:<span class="number">-1</span>] <span class="comment"># step=-1，决定了从右往左取值，而start_index=1到end_index=6决定了从左往右取值，两者矛盾。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[] <span class="comment"># 输出为空列表，说明没取到数据。</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;a[<span class="number">6</span>:<span class="number">1</span>] <span class="comment"># step=1，决定了从左往右取值，而start_index=6到end_index=1决定了从右往左取值，两者矛盾。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[] <span class="comment"># 同样输出为空列表。</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;a[:<span class="number">6</span>] <span class="comment"># step=1，从左往右取值，从“起点”开始一直取到end_index=6。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;a[:<span class="number">6</span>:<span class="number">-1</span>] <span class="comment"># step=-1，从右往左取值，从“终点”开始一直取到end_index=6。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;a[<span class="number">6</span>:] <span class="comment"># step=1，从左往右取值，从start_index=6开始，一直取到“终点”。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;a[<span class="number">6</span>::<span class="number">-1</span>] <span class="comment"># step=-1，从右往左取值，从start_index=6开始，一直取到“起点”。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure></li><li><p>4.start_index和end_index全为负（-）索引的情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a[<span class="number">-1</span>:<span class="number">-6</span>] <span class="comment"># step=1，从左往右取值，而start_index=-1到end_index=-6决定了从右往左取值，两者矛盾。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;a[<span class="number">-1</span>:<span class="number">-6</span>:<span class="number">-1</span>] <span class="comment"># step=-1，从右往左取值，start_index=-1到end_index=-6同样是从右往左取值。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;a[<span class="number">-6</span>:<span class="number">-1</span>] <span class="comment"># step=1，从左往右取值，而start_index=-6到end_index=-1同样是从左往右取值。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;a[:<span class="number">-6</span>] <span class="comment"># step=1，从左往右取值，从“起点”开始一直取到end_index=-6。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;a[:<span class="number">-6</span>:<span class="number">-1</span>] <span class="comment"># step=-1，从右往左取值，从“终点”开始一直取到end_index=-6。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;a[<span class="number">-6</span>:] <span class="comment"># step=1，从左往右取值，从start_index=-6开始，一直取到“终点”。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;a[<span class="number">-6</span>::<span class="number">-1</span>] <span class="comment"># step=-1，从右往左取值，从start_index=-6开始，一直取到“起点”。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure></li><li><p>5.start_index和end_index正（+）负（-）混合索引的情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a[<span class="number">1</span>:<span class="number">-6</span>] <span class="comment"># start_index=1在end_index=-6的左边，因此从左往右取值，而step=1同样决定了从左往右取值。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;a[<span class="number">1</span>:<span class="number">-6</span>:<span class="number">-1</span>] <span class="comment"># start_index=1在end_index=-6的左边，因此从左往右取值，但step=-则决定了从右往左取值，两者矛盾。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;a[<span class="number">-1</span>:<span class="number">6</span>] <span class="comment"># start_index=-1在end_index=6的右边，因此从右往左取值，但step=1则决定了从左往右取值，两者矛盾。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;a[<span class="number">-1</span>:<span class="number">6</span>:<span class="number">-1</span>] <span class="comment"># start_index=-1在end_index=6的右边，因此从右往左取值，而step=-1同样决定了从右往左取值。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure></li><li><p>6.连续切片操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a[:<span class="number">8</span>][<span class="number">2</span>:<span class="number">5</span>][<span class="number">-1</span>:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">4</span>]</span><br><span class="line">//相当于：</span><br><span class="line">a[:<span class="number">8</span>]=[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">a[:<span class="number">8</span>][<span class="number">2</span>:<span class="number">5</span>]= [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">a[:<span class="number">8</span>][<span class="number">2</span>:<span class="number">5</span>][<span class="number">-1</span>:] = <span class="number">4</span></span><br><span class="line">//理论上可无限次连续切片操作，只要上一次返回的依然是非空可切片对象。</span><br></pre></td></tr></table></figure></li><li><p>7.切片操作的三个参数可以用表达式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a[<span class="number">2</span>+<span class="number">1</span>:<span class="number">3</span>*<span class="number">2</span>:<span class="number">7</span>%<span class="number">3</span>] <span class="comment"># 即：a[2+1:3*2:7%3] = a[3:6:1]</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure></li><li><p>8.其他对象的切片操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//前面的切片操作说明都以list为例进行说明，但实际上可进行的切片操作的数据类型还有很多，包括元组、字符串等等。</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)[:<span class="number">3</span>] <span class="comment"># 元组的切片操作</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;<span class="string">&#x27;ABCDEFG&#x27;</span>[::<span class="number">2</span>] <span class="comment"># 字符串的切片操作</span></span><br><span class="line">&gt;&gt;&gt;<span class="string">&#x27;ACEG&#x27;</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">100</span>)[<span class="number">2</span>::<span class="number">3</span>][<span class="number">-10</span>:]: <span class="comment"># 利用range函数生成1-99的整数，然后取3的倍数，再取最后十个。</span></span><br><span class="line">       print(i, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">72</span> <span class="number">75</span> <span class="number">78</span> <span class="number">81</span> <span class="number">84</span> <span class="number">87</span> <span class="number">90</span> <span class="number">93</span> <span class="number">96</span> <span class="number">99</span></span><br></pre></td></tr></table></figure></li><li><p>9.取偶数位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;b = a[::<span class="number">2</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure></li><li><p>10.取奇数位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;b = a[<span class="number">1</span>::<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure></li><li><p>11.拷贝整个对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;b = a[:] <span class="comment"># ★★★★★</span></span><br><span class="line">&gt;&gt;&gt;print(b) <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line">&gt;&gt;&gt;print(id(a)) <span class="comment"># 41946376</span></span><br><span class="line">&gt;&gt;&gt;print(id(b)) <span class="comment"># 41921864</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;b = a.copy()</span><br><span class="line">&gt;&gt;&gt;print(b) <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line">&gt;&gt;&gt;print(id(a)) <span class="comment"># 39783752</span></span><br><span class="line">&gt;&gt;&gt;print(id(b)) <span class="comment"># 39759176</span></span><br><span class="line">//需要注意的是：[:]和.copy()都属于“浅拷贝”，只拷贝最外层元素，内层嵌套元素则通过引用，而不是独立分配内存。</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;a = [<span class="number">1</span>,<span class="number">2</span>,[<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>]]</span><br><span class="line">&gt;&gt;&gt;print(<span class="string">&#x27;a=&#123;&#125;&#x27;</span>.format(a))</span><br><span class="line">a=[<span class="number">1</span>, <span class="number">2</span>, [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]] <span class="comment"># 原始a</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;b = a[:]</span><br><span class="line">&gt;&gt;&gt;b[<span class="number">0</span>] = <span class="number">9</span> <span class="comment"># 修改b的最外层元素，将1变成9</span></span><br><span class="line">&gt;&gt;&gt;b[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">&#x27;D&#x27;</span> <span class="comment"># 修改b的内嵌层元素</span></span><br><span class="line">&gt;&gt;&gt;print(<span class="string">&#x27;a=&#123;&#125;&#x27;</span>.format(a)) <span class="comment"># b修改内部元素A为D后，a中的A也变成了D，说明共享内部嵌套元素，但外部元素1没变。</span></span><br><span class="line">a=[<span class="number">1</span>, <span class="number">2</span>, [<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]] </span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;print(<span class="string">&#x27;b=&#123;&#125;&#x27;</span>.format(b)) <span class="comment"># 修改后的b</span></span><br><span class="line">b=[<span class="number">9</span>, <span class="number">2</span>, [<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]] </span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;print(<span class="string">&#x27;id(a)=&#123;&#125;&#x27;</span>.format(id(a)))</span><br><span class="line">id(a)=<span class="number">38669128</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;print(<span class="string">&#x27;id(b)=&#123;&#125;&#x27;</span>.format(id(b)))</span><br><span class="line">id(b)=<span class="number">38669192</span></span><br></pre></td></tr></table></figure></li><li><p>12.修改单个元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a[<span class="number">3</span>] = [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>], <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure></li><li><p>13.在某个位置插入元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a[<span class="number">3</span>:<span class="number">3</span>] = [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">&gt;&gt;&gt;a[<span class="number">0</span>:<span class="number">0</span>] = [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure></li><li><p>14.替换一部分元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a[<span class="number">3</span>:<span class="number">6</span>] = [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何搭建个人博客</title>
      <link href="/2020/02/07/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/02/07/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="1-node安装"><a href="#1-node安装" class="headerlink" title="1.node安装"></a>1.node安装</h3><ul><li>从官网下载所需版本：<a href="https://nodejs.org/en/download/">Node.js</a>；</li><li>根据提示完成安装（记住安装的路径）；</li><li>测试是否完成安装：<br>打开命令行窗口（win+R）,输入cmd,回车打开窗口，分别输入 node -v 和 npm -v 回车，显示版本则安装成功；</li><li>环境变量配置：<br>依次打开“我的电脑”-右键-“属性”-“高级系统设置”-“高级”-“环境变量”，找到Path，点击编辑，新建，将Node.js安装路径中bin文件夹路径复制于此即可；</li></ul><a id="more"></a><h3 id="2-Git安装"><a href="#2-Git安装" class="headerlink" title="2.Git安装"></a>2.Git安装</h3><ul><li><p>从官网下载安装：<a href="https://desktop.github.com/">Github for windows</a></p></li><li><p>具体安装可以参考: <a href="https://desktop.github.com/">博客</a></p></li></ul><h3 id="3-注册GitHub账号"><a href="#3-注册GitHub账号" class="headerlink" title="3.注册GitHub账号"></a>3.注册GitHub账号</h3><ul><li>打开GitHub官网注册好一个账号，<a href="https://github.com/">Github</a>；</li><li>注册好账号之后，新建一个仓库，仓库名字一定要是:”账号名称.github.io”;</li><li>Github SSH配置：<br>找到刚才安装的Git，打开快捷方式 git-bash.exe，打开命令行窗口（win+R，cmd）输入下面的代码后，回车几次。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;刚才注册GitHub账号时的邮箱&quot;</span><br></pre></td></tr></table></figure></li><li>SSH配置：<br>在C盘，打开用户文件夹，找到.ssh文件夹,找到名为id_rsa.pub的文件，用记事本打开，复制其中的内容；之后打开github账号，点击Settings,找到SSH and GPG keys,新建SSH keys,Title 可随意写，然后复制刚才id_rsa.pub文件里的内容到keys,保存即可。</li></ul><h3 id="4-hexo使用"><a href="#4-hexo使用" class="headerlink" title="4.hexo使用"></a>4.hexo使用</h3><ul><li>浏览器打开 <a href="https://hexo.io/zh-cn/">hexo</a>，阅读教程；</li><li>在本地磁盘新建一个文件夹Blog(名字随意),然后cd到Blog文件夹下，依次输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br><span class="line">$ hexo init blog &#x2F;&#x2F;其中blog，名字也可随意</span><br><span class="line">$ cd blog</span><br><span class="line">$ npm install</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure></li><li>在浏览器中输入localhost：4000即可看到个人博客。</li></ul><h3 id="5-hexo部署至github"><a href="#5-hexo部署至github" class="headerlink" title="5.hexo部署至github"></a>5.hexo部署至github</h3><ul><li>cd 到blog文件夹下，输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li>用VScode、Sublime或者Atom等编辑器打开blog文件夹，打开_config.yml配置文件，将url后的地址改为<a href="https://github账号名称.github.io/">https://github账号名称.github.io</a>;</li><li>更改最后位置处为<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">https://github.com/账户名/账户名.github.io.git</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></li><li>在命令行窗口，输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure></li><li>即可部署到github上，个人博客搭建成功。</li></ul><h3 id="6-hexo主题更改"><a href="#6-hexo主题更改" class="headerlink" title="6.hexo主题更改"></a>6.hexo主题更改</h3><ul><li>搭建好个人博客后，可以根据自己的喜好选择适合的<a href="https://hexo.io/themes/">主题</a>进行配置.</li><li>此处推荐两款好的主题<a href="https://theme-next.org/">next</a>和<a href="https://jerryc.me/">Butterfly</a>.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
